import { _ as _export_sfc, c as createElementBlock, b as createBaseVNode, t as toDisplayString, a as createStaticVNode, o as openBlock } from "./app.7c456025.js";
const __pageData = '{"title":"Shuttle.Core.Mediator","description":"","frontmatter":{"title":"Shuttle.Core.Mediator","layout":"api"},"headers":[{"level":2,"title":"IMediator","slug":"imediator"},{"level":2,"title":"IParticipant","slug":"iparticipant"}],"relativePath":"infrastructure/shuttle-core-mediator.md"}';
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="shuttle-core-mediator" tabindex="-1">Shuttle.Core.Mediator <a class="header-anchor" href="#shuttle-core-mediator" aria-hidden="true">#</a></h1><div class="language-"><pre><code>PM&gt; Install-Package Shuttle.Core.Mediator\n</code></pre></div><p>The Shuttle.Core.Mediator package provides a <a href="https://en.wikipedia.org/wiki/Mediator_pattern" target="_blank" rel="noopener noreferrer">mediator pattern</a> implementation.</p><h2 id="imediator" tabindex="-1">IMediator <a class="header-anchor" href="#imediator" aria-hidden="true">#</a></h2><p>The core interface is the <code>IMediator</code> interface and the default implementation provided is the <code>Mediator</code> class.</p><p>This interface provides a synchronous calling mechanism and all <code>IParticipant</code> implementations need to be thread-safe singleton implementations that are added to the mediator at startup. Any operations that require transient mechanisms should be handled by the relevant participant.</p><div class="language-c#"><pre><code><span class="line"><span style="color:#FFCB6B;">IMediator</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Add</span><span style="color:#89DDFF;">(object</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">participant</span><span style="color:#89DDFF;">);</span></span>\n<span class="line"></span></code></pre></div><p>The <code>Add</code> method registers the given participant.</p><div class="language-c#"><pre><code><span class="line"><span style="color:#89DDFF;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Send</span><span style="color:#89DDFF;">(object</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">message</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">CancellationToken</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">cancellationToken</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> default</span><span style="color:#89DDFF;">);</span></span>\n<span class="line"></span></code></pre></div><p>The <code>Send</code> method will find all participants that implements the <code>IParticipant&lt;T&gt;</code> with the type <code>T</code> of the message type that you are sending. Participants that are marked with the <code>BeforeObserverAttribute</code> filter will be executed first followed by all participants with no filters attributes and then finally all participants marked with the <code>AfterObserverAttribute</code> filter will be called.</p><h4 id="extensions" tabindex="-1">Extensions <a class="header-anchor" href="#extensions" aria-hidden="true">#</a></h4><div class="language-c#"><pre><code><span class="line"><span style="color:#FFCB6B;">Task</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">SendAsync</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">this</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">IMediator</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">mediator</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">object</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">message</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">CancellationToken</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">cancellationToken</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> default</span><span style="color:#89DDFF;">)</span></span>\n<span class="line"></span></code></pre></div><p>Sends a message asynchronously.</p><div class="language-c#"><pre><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">T</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Send</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">&gt;(</span><span style="color:#C792EA;">this</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">IMediator</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">mediator</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">T</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">message</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">CancellationToken</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">cancellationToken</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> default</span><span style="color:#89DDFF;">)</span></span>\n<span class="line"></span></code></pre></div><p>The same as <code>Send</code> except that it returns the given message.</p><div class="language-c#"><pre><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">RegisterMediatorParticipants</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">this</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">IComponentRegistry</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">registry</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">string</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">assemblyName</span><span style="color:#89DDFF;">)</span></span>\n<span class="line"><span style="color:#A6ACCD;">public static void RegisterMediatorParticipants</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">this</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">IComponentRegistry</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">registry</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Assembly</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">assembly</span><span style="color:#89DDFF;">)</span></span>\n<span class="line"></span></code></pre></div><p>Registers all types that implement the <code>IParticipant&lt;T&gt;</code> interface against the open generic type <code>IParticipant&lt;&gt;</code>.</p><div class="language-c#"><pre><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">AddMediatorParticipants</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">this</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">IComponentResolver</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">resolver</span><span style="color:#89DDFF;">)</span></span>\n<span class="line"></span></code></pre></div><p>Adds any participant instances registered against the open generic <code>IParticipant</code> to the registered <code>IMediator</code> instance.</p><h2 id="iparticipant" tabindex="-1">IParticipant <a class="header-anchor" href="#iparticipant" aria-hidden="true">#</a></h2><div class="language-c#"><pre><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">IParticipant</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">in</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ProcessMessage</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">IParticipantContext</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">context</span><span style="color:#89DDFF;">);</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div><p>A participant would handle the message that is sent on using the mediator.</p><p>There are no <em>request/response</em> semantics and the design philosophy here is that the message encapsulates the state that is passed along in a <em>pipes &amp; filters</em> approach.</p><p>There may be any number of participants that process the message.</p><h1 id="considerations" tabindex="-1">Considerations <a class="header-anchor" href="#considerations" aria-hidden="true">#</a></h1><p>The mediator may be as broad or narrow as is applicable. You could create a new mediator and add only the relevant participants to solve a particular use-case or you could have a central mediator registered in your dependency injection container of choice to provide decoupling across your system.</p><p>If you have a rather predictable sequential workflow and you require something faster then you may wish to consider the [Shuttle.Core.Pipelines] package. A performance testing application for your use-case would be able to indicate the more suitable option.</p>', 27);
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    _hoisted_1,
    createBaseVNode("p", null, "[Shuttle.Core.Pipelines]: " + toDisplayString("/shuttle-core-pipelines" | _ctx.relative_url), 1)
  ]);
}
var shuttleCoreMediator = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { __pageData, shuttleCoreMediator as default };
